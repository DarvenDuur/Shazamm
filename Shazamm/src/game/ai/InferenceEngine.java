package game.ai;

import game.Turn;
import java.util.HashSet;
import java.util.Iterator;

/**
 * Apply inference rules to the fact base
 */
public class InferenceEngine {
    // set of fact bases on wich the inference engine is run
    private HashSet<FactBase> factBases;
    
    // array of knowledge base values, avoid multiple calls of values()
    private static final KnowledgeBase[] KNOWLEDGE_BASE = KnowledgeBase.values();
       
    
    /**
     * Extract fact bases from turn, run engine on them, resolve conflicts,
     *      and determine best course of action
     * @param turn
     *      Current turn
     * @return 
     *      AIAction containing cards to play and mana to bet on this turn
     */
    public static AIAction run(Turn turn) {
        // create new inference engine
        InferenceEngine engine = new InferenceEngine();
        
        // extract all starting fact bases from turn
        engine.factBases = FactBase.extractTurn(turn);
        
        // run inference engine on fact bases
        engine.runEngine();
        
        // return AIAction corresponding to best branch
        return new AIAction(engine.bestFactBase(), turn);
    }
    
    /**
     * run engine on factBases (each rule is applied 1 time on each fact base)
     */
    private void runEngine(){
        // temp fact bases, generated by last rule
        HashSet<FactBase> generatedFactBases=new HashSet<>();
        
        // each rule is applied a single time
        for(KnowledgeBase k : KNOWLEDGE_BASE){
            generatedFactBases.clear();
            
            // apply rule to all fact bases
            for (FactBase factBase : factBases) {
                if(k.isApplicable(factBase)){
                    
                    // add a clone of the fact base with rule applied
                    generatedFactBases.add(k.apply(factBase));
                }
            }
            
            // add new fact bases to previous fact bases
            factBases.addAll(generatedFactBases);
        }
    }
    
    /**
     * find the best fact base in factBases according to the value of evaluate()
     * @return the best factBase
     */
    private FactBase bestFactBase(){
        Iterator  it =factBases.iterator();
        
        // initialize values with first fact base
        FactBase BestFact=factBases.iterator().next();
        int score=BestFact.evaluate();
        int tempScore;
        FactBase tempFactBase;
        
        while(it.hasNext()){
            // evaluate next fact base
            tempFactBase = (FactBase)it.next();
            tempScore = tempFactBase.evaluate();
            
            // if temp fact base is better, use it as new best fact base
            if(tempScore > score){
                score=tempScore;
                BestFact=tempFactBase;
            }
        }
        
        return BestFact;
    }
}
